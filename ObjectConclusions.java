import static java.lang.System.out;
import java.lang.reflect.*;
public class ObjectConclusions
{
	public static void main(String[] args) throws Throwable
	{
		out.println("Object Conclusions !!!");
		
		//1. Checking public String ToString() method
		ToStringCheck firstObj = new ToStringCheck("Baskar", 11400);
		ToStringCheck dupeObj = new ToStringCheck("Baskar", 11400);
		out.println(firstObj);
		out.println(firstObj.toString());
		out.println(Integer.toHexString(firstObj.hashCode()));
		out.println("HashCode => " + firstObj.hashCode());
		out.println(firstObj.getClass().getName());
		String checkToString = new String("Baskar");
		String dupObjEqualsComp = new String("Baskar");
		out.println(checkToString); //toString is overridden
		StringBuilder sbObj = new StringBuilder("Baskar");
		StringBuilder dupeSbObj = new StringBuilder("Baskar");
		out.println(sbObj);//StringBuilder toString() is not overridden
		StringBuffer sbuffObj = new StringBuffer("Baskar");
		StringBuffer dupeSbuffObj = new StringBuffer("Baskar");
		StringBuffer dupeSbuffObjCp = dupeSbuffObj;
		out.println(sbuffObj);//StringBuffer toString()  is not overridden
		//2. Checking "public native int hashCode()" method
		
		//hashCode is not reference/Address its a unique number generated based on address generated by JVM for every Object which 
		//will be used in hashing related data structures(hashSet, hashMap, hashTable)
		out.println("Check equals() of String => " + dupObjEqualsComp.equals(checkToString));
		out.println("Check equals() of Custom Obj => " + firstObj.equals(dupeObj));
		out.println("Check equals() of StringBuilder =>" + dupeSbObj.equals(sbObj));
		out.println("Check == of StringBuilder =>" + (dupeSbObj==sbObj));
		out.println("Check equals() of StringBuffer => " + dupeSbuffObj.equals(sbuffObj));
		out.println("Check == of StringBuffer => " + (dupeSbuffObj==sbuffObj));
		out.println("Check equals() of StringBuffer Reference Comp=> " + dupeSbuffObj.equals(dupeSbuffObjCp));
		out.println("Check == of StringBuffer Reference Comp=> " + (dupeSbuffObj==dupeSbuffObjCp));
		
		out.println("instanceof operator check sametype =>" + (sbObj instanceof StringBuilder));//toString is overridden
		out.println("instanceof operator checkparent=>" + (sbObj instanceof Object));//toString is overridden
		
		//removing custom objet reference bounds and invoking GC to call our custom object finalize method.
		firstObj = null;
		dupeObj = null;
		System.gc(); 
		
		//checking getClass() method
		Object stringObj = new String("Baskar Kadari Suribabu");
		Class stringObjClass = stringObj.getClass();
		out.println("Fully Qualified name of Class : " + stringObjClass.getName());
		Method[] m = stringObjClass.getDeclaredMethods();
		int count = 0;
		for (Method func : m)
		{
			++count;
			out.println(func.getName());
		}
		out.println("total No of methods in String Class is : " + count);
	}
}

class ToStringCheck {
	private String name;
	private int idNo;
	
	ToStringCheck(final String name, final int idNo)
	{
		this.name = name;
		this.idNo = idNo;
	}
	
	//overriding toString() method (all wrapperClasses, collection classes, string, stringbuffer, stringBuilder => toString() is overridden
	// to show meaningful representation, highly recommended to override for our defined classes
	public String toString()
	{
		return name +"..."+ hashCode();
	}
	//overriding hashcode is possible and said to be proper if and only if we are able to generate unique number for every object
	public int hashCode()
	{
		return idNo;
	}
	
	public boolean equals(Object obj)
	{
		if (this == obj) return true;
		if (obj instanceof ToStringCheck) // this check avoid CCE and NPE (null instanceof obj is false)
		{
			ToStringCheck temp = (ToStringCheck) obj;
			if (temp.name.equals(name) && idNo == temp.idNo)
				return true;
			else return false;
		} else return false;
	}
	
	protected void finalize() throws Throwable
	{
		out.println("FINALIZE METHOD CALLED BY GC");
	}
}